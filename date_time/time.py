import time

# time.time() повертає поточний час у секундах з 1 січня 1970 року (epoch time) - `timestamp`
current_time = time.time()
print(f"Поточний час: {current_time}")


# time.sleep(seconds) - Метод зупиняє виконання програми на вказану кількість секунд
print("Початок паузи")
time.sleep(5)
print("Кінець паузи")

# time.ctime([seconds]) - перетворює часову мітку (кількість секунд) у зрозуміле для людини
# текстове представлення. Якщо аргумент не вказаний, використовується поточний час

current_time = time.time()
print(f"Поточний час: {current_time}")

readable_time = time.ctime(current_time)
print(f"Читабельний час: {readable_time}")

# time.localtime([seconds]) -  перетворює часову мітку в структуру struct_time у місцевій часовій зоні.

current_time = time.time()
print(f"Поточний час: {current_time}")  # Поточний час: 1671417470.0

# перетворюємо часову мітку в структуру struct_time
local_time = time.localtime(current_time)
# Місцевий час: time.struct_time(tm_year=2023, tm_mon=12, tm_mday=18, tm_hour=2, tm_min=57, tm_sec=50, tm_wday=0, tm_yday=352, tm_isdst=0)
print(f"Місцевий час: {local_time}")

# time.struct_time в Python є іменованим кортежем, який використовується для представлення часу.
# Кожен елемент кортежу має особливе значення, що представляє певний компонент дати та часу:

# tm_year - рік
# tm_mon - місяць від 1 до 12
# tm_mday - день місяця від 1 до 31
# tm_hour - години від 0 до 23
# tm_min - хвилини від 0 до 59
# tm_sec - секунди від 0 до 59
# tm_wday - день тижня від 0 до 6
# tm_yday - день року від 1 до 366
# tm_isdst - прапорець літнього часу. 0 означає, що літній час не діє, -1 - інформація відсутня,
# 1 - літній час діє

# time.gmtime([seconds]) - схожий на localtime, але повертає struct_time у UTC.

# time.perf_counter() - надає доступ до лічильника з високою точністю, та є ідеальним
# для вимірювання коротких інтервалів часу

# Записуємо час на початку виконання
start_time = time.perf_counter()

# Виконуємо якусь операцію
for _ in range(1_000_000):
    pass  # Просто проходить цикл мільйон разів

# pass - це пустий оператор, який не робить нічого. Він використовується там,
# де синтаксис вимагає наявності хоча б однієї інструкції,
# але вам не потрібно виконувати жодних дій

# Записуємо час після виконання операції
end_time = time.perf_counter()

# Розраховуємо та виводимо час виконання
execution_time = end_time - start_time
print(f"Час виконання: {execution_time} секунд")

# в Python представлення чисел з підкресленнями _ є способом зробити великі числа більш читабельними.
# Наприклад, число 1_000_000 еквівалентне 1000000
# Один мільйон
a = 1_000_000
print(a)  # Виведе 1000000

# Десять мільйонів
b = 10_000_000
print(b)  # Виведе 10000000

# Один мільярд
c = 1_000_000_000
print(c)  # Виведе 1000000000
