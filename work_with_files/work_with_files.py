
# fh - це файловий об'єкт, через який ми можемо працювати з файлом
# Якщо не вказати, як ми хочемо відкрити файл, то він відкривається
# тільки для зчитування даних і за допомогою fh можна буде тільки
# читати дані з файлу.
fh = open('work_with_files/test_file.txt', 'w+')

# w+ - файл в режимі для читання та запису, але сам файл ми перезаписуємо, якщо він існує
# open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

# file - шлях до файлу у вигляді рядка. Це може бути повний шлях або шлях відносно поточного каталогу виконання.
# mode (необов'язковий) - режим, в якому буде відкрито файл.
# Ось основні режими які ми будемо використовувати:
# 'r' - читання (за замовчуванням). Файл має існувати.
# 'w' - запис. Створює новий файл або перезаписує, що вже існує.
# 'a' - додавання. Дописує в кінець файлу, не перезаписуючи його.
# 'b' - бінарний режим (може бути використаний разом з іншими, наприклад 'rb' або 'wb').
# '+' - оновлення (читання та запис).
# buffering (необов'язковий) - визначає буферизацію: 0 для вимкненої,
#            1 для включеної буферизації рядків, більше 1 для вказання розміру буфера у байтах.
# encoding (необов'язковий) - ім'я кодування, яке буде використовуватися для кодування або декодування файлу.
# errors (необов'язковий) - вказує, як обробляти помилки кодування.
# newline (необов'язковий) - контролює, як обробляються нові рядки.
# closefd (необов'язковий) - має бути True (за замовчуванням); якщо вказано False,
# файловий дескриптор не буде закритий.
# opener (необов'язковий) - визначає спеціальну функцію для відкриття файлу.

symbols_written = fh.write('hello!')
print(symbols_written)  # 6 - повертає кількість записаних символів

# метод seek - переміщуємо вказівник на початок файлу
# приймає один обов'язковий аргумент - кількість символів, на які потрібно змістити курсор у файлі
# другий опціональний аргумент - вказує, звідки починати зміщення курсора
# tell - метод, який повертає позицію (номер) символу з початку файлу, де зараз знаходиться курсор
fh.seek(0)
first_two_symbols = fh.read(2)
print(first_two_symbols)  # 'he'

position = fh.tell()
print("position:", position)  # position: 2

fh.seek(0)
all_file = fh.read()  # читаємо весь файл
print(all_file)  # 'hello!'
# обов'язково після роботи з файлом його потрібно закрити
fh.close()

# зчитаємо файл знову та виведемо його вміст в стовпчик (в циклі виводимо по одному символу за раз)
fh = open('work_with_files/test_file.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('work_with_files/test_file.txt', 'r')
while True:
    symbol = fh.read(1)
    if len(symbol) == 0:
        break
    print(symbol)

fh.close()

# спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline
fh = open('work_with_files/test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('work_with_files/test.txt', 'r')
while True:
    line = fh.readline()
    if not line:
        break
    print(line)

fh.close()

# аналогічний метод readlines, який читає увесь файл повністю,
# але повертає список рядків, де елемент списку — це один рядок з файлу
# всі методи, які читають файли порядково, залишають (не видаляють) символ перенесення рядка \n.
# ['first line\n', 'second line\n', 'third line']
# Його, за необхідності, треба видаляти самостійно - можемо використати метод strip()


fh = open('work_with_files/test_two.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('work_with_files/test_two.txt', 'r')
lines = [el.strip() for el in fh.readlines()]
print(lines)

fh.close()
