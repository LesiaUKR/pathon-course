import re
# Основні компоненти регулярних виразів включають:

# Літерали. Пряме відображення символів (наприклад, a, B, 1).
# Метасимволи. Символи, які мають спеціальне значення в регулярних виразах (наприклад, . (крапка) відповідає будь-якому символу).
# Квантифікатори. Визначають, скільки разів елемент повинен відповідати (наприклад * означає 0 або більше повторень).
# Класи символів. Визначають групи символів (наприклад, [a-z] відповідає будь-якій малій літері).
# Групи та діапазони. Використовуються для групування частин виразу (наприклад, (abc) визначає групу символів).
# Альтернації. Відповідає одному з декількох шаблонів (наприклад, a|b відповідає a або b).
# Якорі. Визначають позиції у тексті (наприклад, ^ для початку рядка, $ для кінця рядка).

# приклади регулярних виразів:
# \w — будь-яка цифра або буква [a-zA-Z0-9_] (\W — все, крім букви або цифри [^a-za-z0-9_])
# \d — будь-яка цифра [0-9] (\D — усе, крім цифри [^0-9])
# \s — будь-який пробільний символ [\t\n\r\f\v] (\S — усе, крім пробільних символів [^\t\n\r\f\v])
# \b — межа слова
# [...] — один із символів у дужках ([^ ] — будь-який символ, крім тих, що в дужках)
# ^ і $ — початок і кінець рядка відповідно
# ( ) — групує вираз і повертає знайдений текст
# \t, \n, \r — символ табуляції, нового рядка та повернення каретки

# Модифікатори
# . — один будь-який символ, крім рядка \n
# \ ? — 0 або 1 входження шаблону зліва
# + — 1 і більше входжень шаблону зліва
# * — 0 і більше входжень шаблону зліва
# \ — екранування спец.символів (приклад: \. — означає крапку або \+ — знак "плюс")
# {n} суворо n разів (n ціле число)
# {n,m} — від n до m входжень (приклад: {,m} — від 0 до m)
# a|b — відповідає a або b. Сам символ | означає "або" між двома шаблонами
# ( ) — групує вираз і повертає знайдений текст


# Методи модуля re

# re.search(pattern, string, flags=0) — повертає спеціальний об'єкт Match,
# якщо шаблон було знайдено в рядку, інакше None
# pattern: Регулярний вираз (шаблон), який ви хочете знайти.
# string: Рядок, у якому ви хочете знайти шаблон.

# Match.span() повертає кортеж, що містить початкову та кінцеву позиції збігу.
# Match.string повертає рядок, переданий у функцію,
# Match.group() повертає частину рядка, в якому був збіг

text = "Вивчення Python може бути веселим."
pattern1 = "Python"
match = re.search(pattern1, text)

if match:
    print("Знайдено:", match.group())
else:
    print("Не знайдено.")


pattern2 = r"в\w*м"
match = re.search(pattern2, text, re.IGNORECASE)

if match:
    print("Знайдено:", match.group())  # виведе "Знайдено: веселим"

# r означає "сирий" рядок (raw string), який каже Python ігнорувати спеціальні символи такі як \n,
# \t тощо, оскільки це рядок для регулярних виразів.
# в - шукаємо слово яке починається на букву "в".
# \w* - це означає будь-яка кількість букв включно з нулем букв.
# Бо \w відповідає будь-якому "словесному" символу, а * є квантифікатором,
# який означає "нуль або більше входжень попереднього елемента".
# м - шукаємо слово яке закінчується на "м".
# re.IGNORECASE -  параметр, який робить пошук нечутливим до регістру


# задача - знаходження електронної адреси в рядку

text2 = "Моя електронна адреса: example@example.com"
pattern3 = r"\w+@\w+\.\w+"
match = re.search(pattern3, text2)

if match:
    print("Електронна адреса:", match.group())

# pattern3 = r"\w+@\w+\.\w+":
# \w+ - спочатку повинні йти одна або більше букв або цифр.
# @ - далі обов'язково повинен бути символ @.
# \w+ - після символу @ повинна йти ще одна серія букв.
# \. - серія букв повинна закінчитись символом крапки.
# Ми екрануємо його, бо в регулярному виразі, крапка є
# модифікатором та має спеціальне значення.
# \w+ - далі йде серія букв після крапки.


# задача - вилучити ім'я користувача та домен цієї електронної адреси окремо.
# Треба розділити "username@domain.com" на "username" (ім'я користувача)
# та "domain.com" (домен).

email = "username@domain.com"
pattern4 = r"(\w+)@(\w+\.\w+)"
match = re.search(pattern4, email)

if match:
    user_name = match.group(1)
    domain_name = match.group(2)
    print("Ім'я користувача:", user_name)
    print("Домен:", domain_name)

# pattern4 = r"(\w+)@(\w+\.\w+)":
# (\w+) - перші круглі дужки відповідають одному або більше словесним символам
# @ - пошук символа  @, що розділяє ім'я користувача та домен
# (\w+\.\w+) - другі круглі дужки відповідають за домену електронної адреси
# \w+ збігається з першою частиною домену,
# \. - це крапка
# ще один \w+ для збігу з доменом верхнього рівня (наприклад, "com")


# re.findall() - метод використовується для знаходження всіх входжень шаблону,
# заданого регулярним виразом, у заданому рядку
# повертає список всіх знайдених відповідностей.
# Якщо відповідностей не знайдено, повертається пустий список.
# Синтаксис методу:
# matches = re.findall(pattern, string)
# pattern - регулярний вираз, який ви шукаєте.
# string - рядок, у якому потрібно знайти відповідності.

text3 = "Рік 2023 був складнішим, ніж 2022"
pattern5 = r"\d+"
matches = re.findall(pattern5, text3)

print(matches)  # ['2023', '2022']

# pattern5 = r"\d+":
# \d+ - шукає одну або більше цифр у рядку підряд та знаходить їх,
# на виході ми отримуємо список всіх чисел в рядку.

# задача- Необхідно зробити вибірку всіх слів в тексті

text4 = "Python - це проста, але потужна мова програмування."
pattern6 = r"\w+"
matches = re.findall(pattern6, text4)

# ['Python', 'це', 'проста', 'але', 'потужна', 'мова', 'програмування']
print(matches)

# pattern6 = r"\w+":
# \w - будь-яка цифра або буква
# + - означає одну або більше входжень шаблону букв або цифр зліва


# задача - знаходження електронних адрес.
# В рядку знаходиться декілька електронних адрес які необхідно добути.

text5 = "Контакти: example1@example.com, example2@sample.org"
pattern7 = r"\w+@\w+\.\w+"
matches = re.findall(pattern7, text5)

# Виведе всі знайдені електронні адреси ['example1@example.com', 'example2@sample.org']
print(matches)


# re.sub() - метод використовується для заміни частини рядка, яка відповідає шаблону,
# Синтаксис:
# modified_string = re.sub(pattern, repl, string)
# pattern - регулярний вираз, який вказує на частину рядка, яку потрібно замінити.
# repl - рядок, на який буде замінено збіги.
# string - рядок, в якому відбувається заміна.
# Метод повертає рядок, у якому всі входження pattern замінені на repl

# задача
# У нас є назва файлу з пробілами, наприклад, "Мій документ Python.txt".
# Нам потрібно перетворити цю назву так, щоб
# замість пробілів були підкреслення,
# отримуючи "Мій_документ_Python.txt".

file_name = "Мій документ Python.txt"
pattern = r"\s"
replacement = "_"
formatted_name = re.sub(pattern, replacement, file_name)

print(formatted_name)  # "Мій_документ_Python.txt"

# pattern = r"\s":
# \s - будь-який пробільний символ

# задача
# Видалимо всі пунктуаційні знаки з рядка
text6 = "Python - потужна, універсальна; мова!"
pattern8 = r"[;,\-:!\.]"
replacement = ""
modified_text = re.sub(pattern8, replacement, text6)

print(modified_text)

# pattern8 = r"[;,\-:!\.]":
# це набір (множина) символів, який включає різні пунктуаційні знаки,
# заміна відбувається на порожній рядок, тобто видаляємо пунктуаційні знаки з рядка.

# задача
# форматування телефонних номерів. Нам необхідно змінити формат телефонних номерів.
# В тексті в нас телефони записані в такому форматі 050-171-1634,
# нам необхідно замінити їх на формат (050) 171-1634

phone = """
        Михайло Куліш: 050-171-1634
        Вікторія Кущ: 063-134-1729
        Оксана Гавриленко: 068-234-5612
        """
pattern9 = r"(\d{3})-(\d{3})-(\d{4})"
replacement2 = r"(\1) \2-\3"
formatted_phone = re.sub(pattern9, replacement2, phone)

print(formatted_phone)  # Виведе телефони в новому форматі
# Михайло Куліш: (050) 171-1634
# Вікторія Кущ: (063) 134-1729
# Оксана Гавриленко: (068) 234-5612

# pattern9 = r"(\d{3})-(\d{3})-(\d{4})":
# (\d{3})-(\d{3})-(\d{4}) шукає телефонні номери в форматі XXX-XXX-XXXX
#  (\d{3} або \d{4}) - група чисел поміщена в круглі дужки для збереження в групах

# replacement2 = r"(\1) \2-\3":
# (\1) - кажемо, що першу групу наприклад треба помістити в круглі дужки, далі пробіл
# \2 - друге число в круглих дужках
# \3 - третє число в круглих дужках
# між групами \2 та \3 залишити дефіс


# re.split() - метод використовується для розділення рядка на частини,
# Синтаксис:
# list_of_elements = re.split(pattern, string)
# pattern - регулярний вираз, який використовується як роздільник.
# string - рядок, який потрібно розділити.
# Метод повертає список рядків, розділених за заданим регулярним виразом

# задача
# розділимо рядок на слова, використовуючи пробіли як роздільники

text7 = "Python - це проста, але потужна мова програмування."
pattern10 = r"\s+"
words = re.split(pattern10, text7)

# Виведе список слів у рядку ['Python', '-', 'це', 'проста,', 'але', 'потужна', 'мова', 'програмування.']
print(words)

# \s+ відповідає одному або більше пробільним символам (пробіл, табуляція тощо).
# виведення буде як у звичайного метода split()

text8 = "Python - потужна; проста, універсальна: мова!"
pattern11 = r"[;,\-:!\s]+"
elements = re.split(pattern11, text8)

# Виведе список частин, розділених пунктуацією ['Python', 'потужна', 'проста', 'універсальна', 'мова', '']
print(elements)

# pattern11 = r"[;,\-:!\s]+":
# [;,\-:!\s]+ збігається з будь-якою послідовністю одного або більше символів з набору ;, ,, -, :, !
# або будь-якого пробільного символу
# + - Завдяки квантифікатору +, послідовність роздільників розглядається як один роздільник,
# що допомагає уникнути створення пустих рядків у результаті виведення.
# Останній пустий елемент, кінець рядка, можна видалити зрізами elements[:-1:]

text9 = "apple#banana!mango@orange;kiwi"
pattern12 = r"[#@;!]"
fruits = re.split(pattern12, text9)

print(fruits)

# pattern12 = r"[#@;!]":
# [#@;!] - створює набір символів, який включає #, @, ;, і !,
# кожен з яких може бути використаний як роздільник.
